// Some useful functions
constant DOMAIN:     func(1, [@(0); int])
constant DATA_AT:    func(1, [@(0); @(1); int])
constant THE_STRING: func(1, [@(0); int])

qualif TabIdx(v:int) : v >= 0
qualif TabIdx(v:int) : v <= 10
qualif TabIdx(v:int) : v < 10
qualif NNTabs(v:ptr) : v != 0 => BLOCK_BEGIN([v]) + 40 < BLOCK_END([v])
qualif Tabs(v:ptr) : BLOCK_BEGIN([v]) + 40 < BLOCK_END([v])

qualif TagsetSng(v:ptr, t:int):     TAGSET([v])                      = Set_sng([t])
qualif NNTagsetSng(v:ptr, p:int): v != 0 => TAGSET([v])              = TAGSET([p])
qualif TagsetSngFld4(v:ptr, t:int): TAGSET([(DEREF([v + 4]) : int)]) = Set_sng([t])
qualif TagsetSngFld8(v:ptr, t:int): TAGSET([DEREF([v + 8])])         = Set_sng([t])
qualif TagsetSelf(v:int):           TAGSET([v])                      = Set_sng([v])
qualif TagsetEqInt(v:int, x:int): TAGSET([v]) = TAGSET([x])

qualif FldEq(v:ptr, a:int): (DEREF([v + 4]) : int) = a
qualif FldEq(v:ptr, a:int): (DEREF([v + 8]) : int) = a

qualif MsgTypeFdTags(v:ptr):    TAGSET([v])              = TAGSET([(DEREF([v + 4]) : int)])
qualif MsgContentFdTags(v:ptr): TAGSET([DEREF([v + 8])]) = TAGSET([(DEREF([v + 4]) : int)])
qualif MsgContentFdDomain(v:ptr): DOMAIN([DEREF([v + 8])]) = DOMAIN([(DEREF([v + 4]) : int)])

qualif TagsetEmpty(v:ptr): ? Set_emp([TAGSET([v])])
qualif TagsetEmpty(v:ptr): ? Set_emp([TAGSET([(DEREF([v + 4]) : int)])])
qualif TagsetEmpty(v:int): ? Set_emp([TAGSET([v])])
qualif NZTag(v:int): v > 0 => ? Set_emp([TAGSET([v])])

qualif ICharOfStr(v:int): v = DATA_AT([VVADDR-BLOCK_BEGIN([VVADDR]);THE_STRING([BLOCK_BEGIN([VVADDR])])])
qualif StringDomain(v:int, p:ptr)          : v != 0 => DOMAIN([v]) = DOMAIN([p])
qualif StringDomain(v:ptr)                 : v != 0 => DOMAIN([v]) = THE_STRING([v])
qualif StringDomain(v:ptr, p:ptr)          : v != 0 => DOMAIN([v]) = THE_STRING([p])
qualif StringDomain(v:ptr, p:ptr)          : v != 0 => DOMAIN([DEREF([v+4])]) = THE_STRING([p])
qualif StringDomain(v:int, p:ptr)          : && [p >= BLOCK_BEGIN([p]); p < BLOCK_END([p])] => DOMAIN([v]) = DOMAIN([p])
qualif DomainIsString(v:ptr, s:ptr)        : DOMAIN([v]) = THE_STRING([s])
qualif StringEq(v:ptr, p:ptr)              : THE_STRING([v]) = THE_STRING([p])
qualif NNStringEq(v:ptr, p:ptr)            : v != 0 => THE_STRING([v]) = THE_STRING([p])
qualif NNStringEq(v:ptr, p:ptr)            : v != 0 => THE_STRING([DEREF([v])]) = THE_STRING([p])
qualif NNDomainEqSelf(v:ptr)               : v != 0 => DOMAIN([v]) = THE_STRING([DEREF([v])])
qualif NNDomainEqString(v:ptr, p:ptr)      : v != 0 => DOMAIN([v]) = THE_STRING([DEREF([p])])
qualif NNDomainCookieEqString(v:ptr, p:ptr): v != 0 => DOMAIN([DEREF([v + 4])]) = THE_STRING([p])
qualif DomainEqPtrs(v:int, p:ptr)          : DOMAIN([v]) = DOMAIN([p])
qualif DomainEqFd(v:ptr, i:int)          : DOMAIN([i]) = DOMAIN([DEREF([v + 4])])
qualif DomainEqNext(v:ptr): DOMAIN([v]) = DOMAIN([DEREF([v + 4])])
//qualif StrCmp(v:int, p:ptr, q:ptr)         : v = 0 => THE_STRING([p]) = THE_STRING([q])

qualif CookieStringEq(v:ptr, c:ptr): THE_STRING([DEREF([v])]) = THE_STRING([DEREF([c])])
qualif StringEqDerefCookieString(v:ptr, c:ptr): THE_STRING([v]) = THE_STRING([DEREF([c])])

qualif DerefFd(v:int, p:ptr): v = (DEREF([p + 4]) : int)
qualif DerefFd(v:int, p:ptr): v = (DEREF([p + 8]) : int)

//Cookie Domain Policy
constant COOKIE_DOMAIN_SET: func(1, [int; int; bool])
constant COOKIE_DOMAIN_GET: func(1, [int; int; bool])
axiom: forall [d:int]. ? COOKIE_DOMAIN_GET([d;d])

//qualif   D1SubD2Set(v:ptr, d:ptr): ? COOKIE_DOMAIN_SET([DOMAIN([v]);DOMAIN([d])])
//qualif   D1SubD2Set(d:int, v:ptr): ? COOKIE_DOMAIN_SET([DOMAIN([v]);DOMAIN([d])])
//qualif   D1SubD2Get(v:ptr, d:ptr): ? COOKIE_DOMAIN_GET([DOMAIN([v]);DOMAIN([d])])
//qualif   D1SubD2Set(v:ptr, d:ptr): ? COOKIE_DOMAIN_SET([DOMAIN([THE_STRING([d])]);DOMAIN([DEREF([v + 4])])])
//qualif   NND1SubD2Get(v:ptr, d:ptr): v != 0 => ? COOKIE_DOMAIN_GET([THE_STRING([d]);DOMAIN([v])])
//qualif   NND1SubD2Set(v:ptr, d:ptr): v != 0 => ? COOKIE_DOMAIN_SET([DOMAIN([THE_STRING([d])]);DOMAIN([DEREF([v + 4])])])
//qualif ListSize(v:ptr, n:int): BLOCK_BEGIN([v]) + n*16 <= BLOCK_END([v])

//qualif MsgSet(v:ptr): ? COOKIE_DOMAIN_SET([DOMAIN([DEREF([v + 8])]);DOMAIN([(DEREF([v+4]) :int)])])
//qualif MsgGet(v:ptr): ? COOKIE_DOMAIN_GET([DOMAIN([DEREF([v + 8])]);DOMAIN([(DEREF([v+4]) :int)])])

// qualif ResCookieDomain(v:ptr, p:ptr): v != 0 => DOMAIN([DEREF([v])]) = DOMAIN([p])
// qualif ResCookieSize(v:ptr, a:int): v != 0 => v + (4*a) <= BLOCK_END([v])
// qualif ParseCookieDomain(v:ptr): v != 0 => DOMAIN([v]) = DOMAIN([DEREF([v])])

//qualif CookieListSize(v:ptr): BLOCK_BEGIN([v]) + 800 <= BLOCK_END([v])

// qualif CookieListStrSz(v:ptr): v != 0 => BLOCK_END([v]) - v >= 16

qualif CookieListDomain(v:ptr, s:ptr): v != 0 => ? COOKIE_DOMAIN_GET([DOMAIN([s]);DOMAIN([v])])

qualif HashIdx(v:int): v < 53
qualif TableSize(v:ptr): v != 0 => BLOCK_BEGIN([v]) + 212 <= BLOCK_END([v])
qualif LinkedList(v:ptr, p:ptr): p > 0 => v > 0

qualif StructDom(v:ptr): v != 0 => &&[DOMAIN([DEREF([v])])    = DOMAIN([v]);
                                      DOMAIN([DEREF([v+4])])  = DOMAIN([v]); 
                                      DOMAIN([DEREF([v+8])])  = DOMAIN([v]); 
                                      DOMAIN([DEREF([v+12])]) = DOMAIN([v])] 
